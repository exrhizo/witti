#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Wirelessly Integrating Topographic Teleoperation Instrument (WITTI)
\end_layout

\begin_layout Author
Brian Smith (bdsmith1@email.arizona.edu)
\begin_inset Newline newline
\end_inset

Brianna Heersink (bmheersink@gmail.com) 
\begin_inset Newline newline
\end_inset

Alex Warren (amwarren@email.arizona.edu)
\end_layout

\begin_layout Date
2/21/2014
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
Team Witty
\end_layout

\begin_layout Standard
\align center
ECE 573 - Software Engineering
\end_layout

\begin_layout Standard
\align center
Professor Sprinkle
\end_layout

\begin_layout Standard
\align center
University of Arizona
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset FloatList figure

\end_inset


\begin_inset Newpage pagebreak
\end_inset

Abstract
\end_layout

\begin_layout Standard
This report provides a description of the implementation details and analysis
 for our application.
 The analysis section includes a description of how the app will function,
 class diagrams, a description of the supported use cases, several example
 sequence diagrams, and a discussion of the important algorithms the application
 will utilize.
 Also included in the analysis are sample screen shots of the various user
 interfaces that will be part of the application.
 After the application analysis section there is a description of how the
 application will be completed, including a timeline and a separation of
 duties.
 The report concludes that the application will be completed on time and
 will accomplish the application goals.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Project Overview
\end_layout

\begin_layout Standard
The LiDAR visualization application is designed to display information collected
 from the LiDAR on a mobile device.
 The app will also allow users to draw a path on top of the visualized point
 cloud to determine if the path is reachable.
 
\end_layout

\begin_layout Standard
LiDAR stands for Light Detection and Ranging.
 LiDAR devices use an array of lasers to collect data that give the distance
 and height values of an array of points stemming out of the LiDAR that
 can be used to determine the physical characteristics of the surrounding
 landscape.
 Typically, LiDAR is used to help autonomous vehicles get information on
 their surroundings.
 
\end_layout

\begin_layout Standard
This app will give researchers the ability to see a subset of what the vehicle
 sees while the vehicle is driving or playback already recorded data.
 This could be useful in debugging unexpected vehicle behavior or determining
 the limitations of the LiDAR when driving.
 This app will also help researchers visualize how and why the vehicle makes
 certain decisions when determining if a chosen path is reachable.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Part
Analysis and Models
\end_layout

\begin_layout Section
Requirements
\end_layout

\begin_layout Subsection*
2.1 'B' Requirements
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
B.1 Display Data: The phone application software shall load and display Velodyne
 LiDAR data on the phone.
\end_layout

\begin_deeper
\begin_layout Standard
Prerequisite(s): None
\end_layout

\begin_layout Standard
Difficulty: 4
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
B.2 Manual Data Refresh: The phone application software shall be capable
 of refreshing the displayed Velodyne LiDAR data manually based on user
 input.
\end_layout

\begin_deeper
\begin_layout Standard
Prerequisite(s): B.1
\end_layout

\begin_layout Standard
Difficulty: 2
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
B.3 Server Download: The phone application software shall be capable of downloadi
ng Velodyne LiDAR data in the form of an XYZ-point text file from a remote
 server.
\end_layout

\begin_deeper
\begin_layout Standard
Prerequisite(s): None
\end_layout

\begin_layout Standard
Difficulty: 3
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
B.4 Server Upload: The host computer software shall be capable of uploading
 Velodyne LiDAR data in the form of an XYZ-point text file to a remote server.
\end_layout

\begin_deeper
\begin_layout Standard
Prerequisite(s): None
\end_layout

\begin_layout Standard
Difficulty: 3
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
B.5 Demo Playback: The phone application shall be able to use XYZ-point text
 files stored locally for Manual Data Refresh mode.
\end_layout

\begin_deeper
\begin_layout Standard
Prerequisite(s): B.2
\end_layout

\begin_layout Standard
Difficulty: 2
\end_layout

\end_deeper
\begin_layout Subsection*
2.2 'A' Requirements
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
A.1 Automatic Data Refresh: The phone application software shall be capable
 of refreshing the displayed Velodyne LiDAR data automatically through a
 set refresh rate.
\end_layout

\begin_deeper
\begin_layout Standard
Prerequisite(s): B.1
\end_layout

\begin_layout Standard
Difficulty: 4
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
A.2 Draw Trajectory: The phone application software shall read a trajectory
 selected by the user through touch events on the phone.
\end_layout

\begin_deeper
\begin_layout Standard
Prerequisite(s): B.1
\end_layout

\begin_layout Standard
Difficulty: 4
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
A.3 Trajectory Clearance: The phone application software shall indicate if
 trajectories would be too close to obstacles.
\end_layout

\begin_deeper
\begin_layout Standard
Prerequisite(s): A.2
\end_layout

\begin_layout Standard
Difficulty: 3
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
A.4 Trajectory Drivability: The phone application software shall reject trajector
ies that are not possible to follow due to vehicle limitations.
\end_layout

\begin_deeper
\begin_layout Standard
Prerequisite(s): A.2
\end_layout

\begin_layout Standard
Difficulty: 3
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
A.5 Perspective Change: The phone application software shall be capable of
 changing the perspective of the displayed data on the phone.
\end_layout

\begin_deeper
\begin_layout Standard
Prerequisite(s): B.1
\end_layout

\begin_layout Standard
Difficulty: 3
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
A.6 Dynamic LiDAR Conversion: The host computer shall be capable of processing
 and converting the PCAP files to phone readable data as they are received
 within a bounded delay that will be established.
\end_layout

\begin_deeper
\begin_layout Standard
Prerequisite(s): None
\end_layout

\begin_layout Standard
Difficulty: 4
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
A.7 JAUS Compatible: The host computer software shall be capable of sending
 JAUS messages containing converted LiDAR data.
\end_layout

\begin_deeper
\begin_layout Standard
Prerequisite(s): None
\end_layout

\begin_layout Standard
Difficulty: 4
\end_layout

\end_deeper
\begin_layout Section
Application Analysis
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
When the app initializes the user is brought to the Introduction screen.
 Here, the user is presented with four buttons that will choose the next
 action: Demo, Launch, and Settings.
 The user can navigate to the settings menu by clicking on the Settings
 button.
 The user can navigate to image viewing by clicking on the Demo button or
 the Launch button.
 
\end_layout

\begin_layout Standard
The Demo button is used initialize Demo mode, which will read point cloud
 data directly from a file stored on the device.
 The Launch button is used to initialize wireless mode, where the phone
 will connect with a host computer in order to receive point cloud data.
\end_layout

\begin_layout Standard
After Demo button or Launch button is pressed the user is presented with
 several settings that must be completed before moving on to data viewing.
 One option is the refresh rate.
 This will be limited in choices, including setting the rate to 0 for the
 ability to refresh manually by tapping the screen.
 The other option will be to set the IP address of the host computer for
 wireless communication.
 This option will be grayed when the Demo button was used to initialize.
\end_layout

\begin_layout Standard
After setting the appropriate settings the user is taken to the ImageView
 screen where point cloud data immediately starts playing at the set refresh
 rate and from the set location.
 While in this state the user can pause the playback, if the refresh rate
 is greater than 0, or choose to draw a path.
 When the user decides to draw a path the playback is automatically paused
 if not already.
 After a valid path is inputted, the app immediately checks for reachability
 and informs the user.
 The user is then taken back to the ImageView in the paused state.
\end_layout

\begin_layout Standard
The user is able to navigate back to the Introduction screen by clicking
 the back button.
 The user can quit the application by clicking the back button at the Introducti
on screen.
 The home button will pause the app.
\end_layout

\begin_layout Subsection
Use Cases
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Phone Application State Diagram
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/state-d.png
	width 95col%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Determine reachability of a drawn path.
 
\end_layout

\begin_layout Description

\series bold
Summary
\series default
: The app determines if the path drawn by the user on the screen is reachable,
 i.e.
 no obstacles in the path.
 
\end_layout

\begin_layout Description
Actors: User 
\end_layout

\begin_layout Description

\series bold
Preconditions
\series default
: The app is viewing point cloud data.
 
\end_layout

\begin_layout Description

\series bold
Description
\series default
: The user first clicks the pause button if the current mode is set to stream
 data.
 Then the user draws a path on the screen of the app.
 The app first checks if the path is valid, i.e.
 does not go out of bounds of the image.
 If the path is valid the app will allow the user to calculate reachability
 or draw a new path.
 After reachability option is chosen the app will tell the user if the current
 path is reachable.
 The app will then exit the path drawing state and return to the image viewing
 with the image paused.
 
\end_layout

\begin_layout Description

\series bold
Exceptions
\series default
: The following exceptions are expected: Invalid path The user draws a path
 outside the boundary of the image.
 The app will give the use a warning popup and clear the screen.
 
\end_layout

\begin_layout Description

\series bold
Postconditions
\series default
: The app returns to the image view screen with the current view paused.
 
\end_layout

\begin_layout Subsubsection
Watching live LiDAR data
\end_layout

\begin_layout Description
Summary: The user is streaming live LiDAR data.
 
\end_layout

\begin_layout Description
Actors: User 
\end_layout

\begin_layout Description
Preconditions: A wireless connection between the device and host computer
 is established.
 
\end_layout

\begin_layout Description
Description: The user is streaming live LiDAR data on the device.
 The user can be located anywhere a good connection between the device and
 the host computer can be established.
 The user can decide between a constant refresh rate and tapping the screen
 to get the current LiDAR view.
 
\end_layout

\begin_layout Description
Exceptions: The following exceptions are expected: Connection Signal Lost
 The connection between the host computer and the device is lost.
 The app will do some memory clean up and then return to the Introduction
 screen.
 
\end_layout

\begin_layout Description
Postconditions: The app terminates.
 
\end_layout

\begin_layout Subsubsection
Demo mode viewing
\end_layout

\begin_layout Description
Summary: The user is streaming live LiDAR data.
 
\end_layout

\begin_layout Description
Actors: User 
\end_layout

\begin_layout Description
Preconditions: A wireless connection between the device and host computer
 is established.
 
\end_layout

\begin_layout Description
Description: The user is streaming live LiDAR data on the device.
 The user can be located anywhere a good connection between the device and
 the host computer can be established.
 The user can decide between a constant refresh rate and tapping the screen
 to get the current LiDAR view.
 
\end_layout

\begin_layout Description
Exceptions: The following exceptions are expected: 
\end_layout

\begin_deeper
\begin_layout Description
Connection
\series bold
 Signal Lost
\series default
 The connection between the host computer and the device is lost.
 The app will do some memory clean up and then return to the Introduction
 screen.
 
\end_layout

\end_deeper
\begin_layout Description
Postconditions: The app terminates.
 
\end_layout

\begin_layout Section
Domain Analysis
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
The application will involve many processes transparent to the user.
 In addition to the software on the phone, hardware and software outside
 of the phone are involved in providing the full functionality on the Android
 app.
\end_layout

\begin_layout Standard
The main functionality of the app is to provide the user a visualization
 of the data collected and saved from the LiDAR.
 The objects and methods involved in refreshing the image displayed on the
 phone can be seen in the sequence model below.
 The preconditions to this sequence model are as follows: 
\end_layout

\begin_layout Enumerate
The app is in the Launch mode rather than the Demo mode.
\end_layout

\begin_layout Enumerate
The app settings are configured to have a refresh rate of 0, which requires
 the user to manually select when the screen should be updated.
\end_layout

\begin_layout Enumerate
The app settings are configured to have the LiDAR data read from a PCAP
 file on the computer’s hard drive.
 
\end_layout

\begin_layout Subsection
Refresh
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Refresh Data Sequence
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/refresh-sequence.png
	width 95col%

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
This sequence model shows the objects involved in getting new LiDAR data
 from the computer and rendering the new image on the app display.
 This involved wireless communication for the data request as well as the
 LiDAR data between the phone and the computer.
\end_layout

\begin_layout Standard
On the computer side, the data is read by the PcapReader.
 The CloudProcessor then converts the data into a point cloud and reduces
 the point cloud sufficiently for the phone to be able to render the data
 relatively quickly.
 The point cloud reduction methods include reducing the field of view of
 the data to only include points in front of the vehicle and using the Point
 Cloud Library’s VoxelGrid filter to downsample the dataset.
 Additionally, the CloudProcessor will determine a GroundPlane based on
 the LiDAR data.
 This GroundPlane can be used on the phone app in the Draw Path use case
 in order to determine the car’s path trajectory on the ground based on
 the user’s touch input.
 Finally, the CloudProcessor will establish a ValidGrid based on the dataset.
 This ValidGrid will identify areas that the vehicle will be able to drive
 over since there are no large objects above the GroundPlan in these areas.
\end_layout

\begin_layout Standard
After the data is read and processed, the PcWifiManager will send the three
 datasets, LidarPoints, GroundPlane, and ValidGrid, to the AppWifiManager
 using the connection that was established upon initializing the wifi communicat
ion between the computer and the phone.
\end_layout

\begin_layout Standard
The phone will then save the LidarPoints, GroundPlane, and ValidGrid.
 The LidarSurfaceView object will call the LidarRender object to render
 the image using the updated data received from the computer.
\end_layout

\begin_layout Standard
Another functionality of the app is the sense the user’s touch trajectory
 after selecting to draw a new path trajectory for the vehicle.
 This will involve calculating the coordinates on the GroundPlane and determinin
g whether these coordinates all fall within the ValidGrid.
 If the path selected by the user leaves the ValidGrid, then the app will
 display an error message using the Alert object.
 If the path falls within the ValidGrid, then the translated path coordinates
 will be sent to the computer through the AppWifiManager and the app will
 display a notification indicating success using the Alert object.
 
\end_layout

\begin_layout Subsection
Settings
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Change Settings Sequence
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/settings-sequence.png
	width 95col%

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The user is currently viewing the HomeActivity user interface.
 The user then taps the Settings button which will use the Android touch
 callback method to call the openSettings() method.
 This will initialize and create the SettingsActivity menu.
 In the SettingsActivity menu, the user can make changes to the different
 settings, including changing the refresh rate and changing the perspective.
 The SettingsActivity will also use the Android touch callback methods to
 determine where the user touches and how to respond appropriately, which
 includes sending messages to the Settings class that holds the values for
 the various settings during the entire application lifetime.
 After the user has finished with the SettingsActivity, the back button
 will be used to initialize the HomeActivity and return the user interface
 to the HomeActivity.
\end_layout

\begin_layout Subsection
System Algorithms
\end_layout

\begin_layout Subsubsection
Network exchange
\end_layout

\begin_layout Standard
The phone and host computer will communicate using wifi and a server host
 relationship.
 Because the host computer will be running software programmed in c++ and
 the phone will be running andriod, this may require developing code to
 manually marshal and demarshal data.
 We will develop a standard set of messages with expected header information
 for socket communication.
\end_layout

\begin_layout Subsubsection
Vehicle Control
\end_layout

\begin_layout Standard
With proper calibration of the LiDAR to real world distances, it is possible
 to map a drawn path to a series of GPS coordinates or to a path in relative
 coordinates.
 The path following code that is currently developed for the CATVehicle
 doesn't allow messages to be transfered directly, but it is possible to
 create a JAUS message that conveys that information or to have spawn the
 process with a datafile created to be loaded as it starts.
\end_layout

\begin_layout Subsubsection
Ground Plane
\end_layout

\begin_layout Standard
The ground plane will be determined by first selecting the points nearest
 the vehicle that are not the vehicle itself.
 The RANSAC algorithm will be used to test possible planes by calculating
 the number of matching points an estimate for the local terrain will be
 determined.
 It can be assumed that the four tires are on a level plane, so that any
 far deviation from this standard will be considered an error.
 Also if the ground is curved it is possible to find the ground plane as
 a series of 
\end_layout

\begin_layout Subsection
Phone Application Algorithms
\end_layout

\begin_layout Subsubsection
3d Display
\end_layout

\begin_layout Standard
Display will be accomplished using the opengl es2 libraries for android.
 There are differnt options depending on what we finally display.
 The ground plane can be displayed as a simple mesh with coloring based
 on the occupancy grid, this can be done with vertex coloring and smooth
 interpolation.
 The points can be displayed as sprites and if we choose to create a mesh
 this will need to be converted from the representation in point cloud library
 to one that can be loaded in opengl.
\end_layout

\begin_layout Subsubsection
Path Drawing
\end_layout

\begin_layout Standard
The path will be drawn onto the ground plane from a 3d perspective.
 Becuase the camera is represented as a matrix that transforms from 3d position
 to a 2d pixel coordination it is possible to use linear algebra to find
 a ray cast from the center of each pixel into the 3d space.
 After finding this line, it is possible to find its intersection with the
 ground plane.
 As the user drags a path accross the map, it may be desierable to smooth
 the path to prevent noise from making the path undrivable.
 The path can be displayed as a series of points or as a mesh.
\end_layout

\begin_layout Subsubsection
Trajectory Clearance
\end_layout

\begin_layout Standard
Clearance of a trajectory will be determined by checking if there is space
 of a perdetermined amount on both sides of the path.
 To fascilitae this, the host computer will send an occupancy grid that
 it calculates based on a check if points exist above each sector with the
 ground plane as a reference.
 This will be a grid with a predetermined size in meters and indexing scheme.
 To save space in transfer the open sectors will be sent as an array to
 the vehicle.
 A simple check would be to see if each point in that path is clear in a
 radius of sectors.
\end_layout

\begin_layout Subsubsection
Trajectory Drivability
\end_layout

\begin_layout Standard
To determine if a path is reachable from a control point of view, we will
 assume that it is traveling below a safety speed.
 From this it is possible to assume that a minimum turn radius will be reachable
 and that as long as the path when suitable interpolated and smoothed does
 not have tighter turns it is reachable.
 This problem could easily be expanded to include issues of under and over
 shoot.
\end_layout

\begin_layout Subsection
Host Computer
\end_layout

\begin_layout Subsubsection
Point Reduction
\end_layout

\begin_layout Standard
Point reduction can be accomplished in many ways.
 The first is to limit the output of the Velodyne by setting speed, field
 of view and range.
 Next it is possible to programmatically ignore points that are deemed unnecessa
ry.
 One option for reducing the number of points is to use a voxel grid to
 reduce the resoultion of the 3d space, this can be done using point cloud
 library.
 Another possibility is to randomly throw out points.
\end_layout

\begin_layout Subsubsection
Mesh Creation
\end_layout

\begin_layout Standard
PCL library has functionality that creates a mesh by gready triangluation
 where close points are assumed to lie on the same surface.
 This could be used to create a mesh, although becuase objects are occluded
 in a static frame, the mesh would be missing backs and we could look into
 patching the holes, or extended the mesh away from the center.
 Also, with persistent mapping it would be possible to refine the mesh with
 more information as the car moves.
\end_layout

\begin_layout Subsubsection*
Ground Mesh
\end_layout

\begin_layout Standard
Similarly to the ground plane, we can use RANSAC to test possible planes,
 checking for accuracy.
 It is also possible that mesh creation will create a ground mesh as a side
 effect, alothough we would need to extract it from the other objects.
 This could be accomplished by starting with the car's natural ground plane
 and extending outwards by adding nearby triangles.
\end_layout

\begin_layout Subsubsection
Persistent Mapping
\end_layout

\begin_layout Standard
Persistent Mapping would be challenging due to timming issues where a small
 differnce in angle can change a distant point's position by a large margin.
 This is an application of Simultaneous Localization and Mapping.
 It would be necessary to recieve data from the IMU regarding orientation
 and to use this probabilistically to update the point cloud.
 Further reseach would be necessary to determine the best approach.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Part
Design and Test
\end_layout

\begin_layout Section
Class Design
\end_layout

\begin_layout Subsection
Class Diagrams
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
App Classes
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/app-classd.png
	width 90col%

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Host Classes
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/host-classd.png
	width 95col%

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Testing Strategy
\end_layout

\begin_layout Subsection
System
\end_layout

\begin_layout Enumerate
The phone sends a message across network and the host computer responds.
 If any of the remaining system tests pass, this passes.
 
\end_layout

\begin_layout Enumerate
The phone requests LiDAR data test over network and response is sent back
 over network.
 The phone checks received data matches stored test LiDAR.
\end_layout

\begin_layout Enumerate
A set settings message is sent from the phone to the host computer and successfu
lly changes the settings to a comprehensive set of configurations.
\end_layout

\begin_layout Enumerate
The phone sends vehicle trajectory test to host computer and the host checks
 received data matches stored test trajectory.
\end_layout

\begin_layout Enumerate
The phone sends refresh request message and it receives complete LiDAR data
 sets.
\end_layout

\begin_layout Enumerate
The phone sends refreshrate request message and it receives complete LiDAR
 data sets at a requested interval.
\end_layout

\begin_layout Enumerate
LiDAR is converted to a data format that can be displayed as mesh.
 Change driver settings commands are sent from the phone to the host computer
 and the driver is restarted with new settings.
\end_layout

\begin_layout Enumerate
A test trajectory is sent from the phone to the host where it results in
 the simulator moving through trajectory.
\end_layout

\begin_layout Subsection
Phone Application
\end_layout

\begin_layout Enumerate
An already prepared mesh or point cloud intermediary message is stored on
 the phone and can be loaded into openGL and drawn.
\end_layout

\begin_layout Enumerate
The phone will generate reasonable paths and determine the user input required
 to create them.
 It will simulate this user input and determine if the created path is similar
 to the initial one.
\end_layout

\begin_layout Enumerate
In combination with part 2.2, paths can be generated that are both good and
 bad.
 The phone will respond to the simulated inputs with behavior appropriate
 to the path.
 The original paths will be created independently by hand using another
 method to cross verify the results This is all be done with test LiDAR
 data in 1.2.
\end_layout

\begin_layout Enumerate
The phone will simulate user input to change the perspective and the openGL
 representation of a camera will change to expected values or in the expected
 way.
 This will depend on the implementation of the perspective changing.
\end_layout

\begin_layout Enumerate
2.3 will be extended to check if paths that meet drivability requirements
 based on independently created and judged paths 
\end_layout

\begin_layout Subsection
Host Computer Application
\end_layout

\begin_layout Enumerate
Using a reference file of PCAP data converted using a matlab script, the
 host software will compare its output to the reference, and may allow some
 difference in the number of points converted
\end_layout

\begin_layout Enumerate
The host software will check that the data being received from the LiDAR
 is consistent with the settings given to the LiDAR in terms of range and
 angle.
\end_layout

\begin_layout Enumerate
A JAUS component will be created that will provide the perform the checks
 in test 3.1 given messages it receives from the JAUS compatible LiDAR component.
\end_layout

\begin_layout Enumerate
With components that pass the requirements or 3.1 the host software will
 be able to convert the data with a predetermined time limit.
\end_layout

\begin_layout Enumerate
A test dataset will be created of fake points from a surface and obstacles
 and noise.
 The test data will be fed into the host computer and the resulting ground
 mesh compared to the surface that generated it to check if error falls
 within a threshold.
\end_layout

\begin_layout Enumerate
Given a pre recorded set of data for the Lidar and IMU, the mapping process
 will create a map that is consistent across time and successfully maps
 a known object as the car drives around it.
\end_layout

\begin_layout Section
Integration with Platform
\end_layout

\begin_layout Standard
The application will be interacting with the platform’s Wi-Fi in order to
 communicate with a host computer.
 When the application starts the streaming mode an initialization process
 between the host computer and the device is launched, which includes instantiat
ing an instance of AppWifiManager.
 The assumption is that a PCWifiManager will already be running on the host
 computer waiting for a connection message from the application.
 
\end_layout

\begin_layout Standard
After a connection is made, the application will then automatically download
 new data from the host computer based on the set refresh rate.
 If the refresh rate is set to zero, the app will only request new data
 from the host computer when the user taps the screen, indicating a refresh
 action.
 The Wi-Fi manager inside of the app will communicate directly with the
 current activity, since that is how user input will be managed.
 There are several methods that will be implemented that will help send
 messages between the AppWifiManager and the current activity, which can
 be directly seen on the class diagram.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Part
Implementation Plan
\end_layout

\begin_layout Section
Task Allocation and Breakdown
\end_layout

\begin_layout Subsection
Breakdown
\end_layout

\begin_layout Standard
Broadly, the tasks are broken down into three categories, computer software,
 wireless interface, and application software.
 Although task allocation may vary throughout the project, the initial allocatio
ns for the “B requirements” are listed below.
 The “A requirements” allocation will be determined upon finalization of
 which requirements will be implemented.
 
\end_layout

\begin_layout Subsection
Responsiblities
\end_layout

\begin_layout Subsubsection
Brian Smith: 
\end_layout

\begin_layout Description
Domain: Computer software 
\end_layout

\begin_layout Description
Requirements: 1.5, 2.3, 3.1
\end_layout

\begin_layout Description
Classes: LidarServer, CloudProcessor, LidarPoints, Reader, PcapReader
\end_layout

\begin_layout Subsubsection
Brianna Heersink: 
\end_layout

\begin_layout Description
Domain: Wireless Interface and Data Settings
\end_layout

\begin_layout Description
Requirements: 1.1, 1.2, 1.3, 1.4, 1.5
\end_layout

\begin_layout Description
Classes: PcDataSettings, PcWifiManager, AppWifiManager, AppSettings, SettingsAct
ivity
\end_layout

\begin_layout Subsubsection
Alex Warren: 
\end_layout

\begin_layout Description
Domain: Application software 
\end_layout

\begin_layout Description
Requirements: 1.5, 2.1, 2.2, 2.3
\end_layout

\begin_layout Description
Classes: HomeActivity, DisplayActivity, LidarGLSurfaceView, LidarRender,
 LidarFrame, PointFrame, CarPath, UserInput, Alert 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Timeline
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/Timeline.pdf
	width 95col%

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Global/Shared Tasks and Experience
\end_layout

\begin_layout Standard
The integration of all components will be a shared task between all group
 members.
 Additionally, all members will write tests, either for their own requirements
 or for other’s requirements depending on the individual workloads.
 Finally, all members will review each other’s code and contribute to required
 documentation that is submitted throughout the project.
 
\end_layout

\begin_layout Standard
The task allocation was determined to allow the work to be divided and then
 and integrated easily.
 Alex was interested in gaining more experience with OpenGL, so his task
 allocation included working on the data visualization.
 The remaining tasks were split between Brian and Brianna.
 
\end_layout

\end_body
\end_document
